<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>City Delivery Final</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; font-family: 'Segoe UI', sans-serif; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD */
        .top-hud { display: flex; justify-content: space-between; padding: 20px; align-items: flex-start; }

        #score-card {
            background: linear-gradient(135deg, #ff9900, #ffcc00);
            color: #000; padding: 10px 20px; border-radius: 10px;
            font-weight: 800; font-size: 22px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3); border: 2px solid #fff;
        }

        #minimap-frame {
            width: 150px; height: 150px; background: rgba(20, 20, 20, 0.9);
            border: 4px solid #888; border-radius: 50%; overflow: hidden;
            box-shadow: 0 5px 20px rgba(0,0,0,0.6); position: relative;
        }
        /* Bordi minimappa per indicare NORD */
        #minimap-frame::after {
            content: 'N'; position: absolute; top: 5px; left: 50%; transform: translateX(-50%);
            color: #fff; font-size: 12px; font-weight: bold; pointer-events: none;
        }

        #minimap-canvas { width: 100%; height: 100%; display: block; }

        /* Game Over */
        #game-over-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(5px);
            display: none; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto; z-index: 30;
        }
        h1 { color: #e74c3c; font-size: 32px; margin-bottom: 10px; text-transform: uppercase; }
        p { color: #ccc; font-size: 16px; margin-bottom: 30px; }
        button.retry-btn {
            background: #3498db; color: #fff; border: none; padding: 15px 50px;
            font-size: 18px; font-weight: bold; border-radius: 30px; cursor: pointer;
            box-shadow: 0 0 15px rgba(52, 152, 219, 0.5);
        }
        button.retry-btn:active { transform: scale(0.95); }

        /* Joystick Area */
        #joystick-zone { width: 100%; height: 40%; pointer-events: auto; position: relative; }
        #stick-base {
            width: 100px; height: 100px; border: 2px solid rgba(255,255,255,0.2);
            background: rgba(255,255,255,0.05); border-radius: 50%;
            position: absolute; display: none;
        }
        #stick-handle {
            width: 50px; height: 50px; background: rgba(255,255,255,0.8); border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        .tutorial {
            position: absolute; bottom: 20px; width: 100%; text-align: center;
            color: rgba(255,255,255,0.4); font-size: 14px; pointer-events: none;
        }
    </style>
</head>
<body>

<div id="ui-layer">
    <div class="top-hud">
        <div id="minimap-frame"><canvas id="minimap-canvas"></canvas></div>
        <div id="score-card">üì¶ <span id="score">0</span></div>
    </div>
    <div class="tutorial">GUIDA CON PRUDENZA</div>
    <div id="joystick-zone">
        <div id="stick-base"><div id="stick-handle"></div></div>
    </div>
</div>

<div id="game-over-screen">
    <h1>Incidente!</h1>
    <p>Rispetta il codice della strada.</p>
    <button class="retry-btn" onclick="resetGame()">RIPROVA</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
    // --- SETTINGS ---
    const MAP_SIZE = 14; // 14x14 tiles
    const TILE_SIZE = 8; // Pi√π largo per guidare meglio
    const OFFSET = (MAP_SIZE * TILE_SIZE) / 2 - (TILE_SIZE / 2);
    
    // --- SCENE ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x88ccee);
    scene.fog = new THREE.Fog(0x88ccee, 30, 90);

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 300);
    camera.position.set(0, 40, 30);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    // --- LIGHTS ---
    const ambientLight = new THREE.AmbientLight(0x404040, 1.2);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffee, 0.8);
    dirLight.position.set(-40, 80, -40);
    dirLight.castShadow = true;
    dirLight.shadow.mapSize.set(2048, 2048);
    const d = 80;
    dirLight.shadow.camera.left = -d; dirLight.shadow.camera.right = d;
    dirLight.shadow.camera.top = d; dirLight.shadow.camera.bottom = -d;
    scene.add(dirLight);

    // --- TEXTURES & MATERIALS ---
    function createBuildingTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        
        // Muro
        ctx.fillStyle = '#606065'; ctx.fillRect(0,0,64,128);
        
        // Finestre
        for(let y=10; y<120; y+=16) {
            for(let x=8; x<56; x+=16) {
                ctx.fillStyle = Math.random()>0.3 ? '#ffeb3b' : '#2c3e50'; // Giallo o spento
                ctx.fillRect(x,y,10,10);
            }
        }
        const tex = new THREE.CanvasTexture(canvas);
        tex.magFilter = THREE.NearestFilter;
        return tex;
    }
    const texBuilding = createBuildingTexture();
    const matWall = new THREE.MeshStandardMaterial({ map: texBuilding });
    const matRoof = new THREE.MeshStandardMaterial({ color: 0x333333 });
    // Materiali per BoxGeometry (Right, Left, Top, Bottom, Front, Back)
    // Top √® index 2
    const materialsBuilding = [matWall, matWall, matRoof, matWall, matWall, matWall];

    // --- ASSETS GENERATION ---

    // 1. TRUCK (Player) - Ottimizzato per guida
    function createTruck() {
        const truck = new THREE.Group();
        const w = 1.4; // Larghezza ridotta per passare meglio

        // Chassis
        const chassis = new THREE.Mesh(new THREE.BoxGeometry(w, 0.5, 3.8), new THREE.MeshStandardMaterial({color:0x222}));
        chassis.position.y = 0.5; chassis.castShadow=true;
        truck.add(chassis);

        // Cabina
        const cab = new THREE.Mesh(new THREE.BoxGeometry(w, 1.4, 1.2), new THREE.MeshStandardMaterial({color:0xffaa00}));
        cab.position.set(0, 1.4, 1.2); cab.castShadow=true;
        truck.add(cab);

        // Vetro
        const glass = new THREE.Mesh(new THREE.PlaneGeometry(w-0.1, 0.7), new THREE.MeshStandardMaterial({color:0x6699cc}));
        glass.position.set(0, 1.6, 1.81);
        truck.add(glass);

        // Carico
        const cargo = new THREE.Mesh(new THREE.BoxGeometry(w+0.1, 1.8, 2.4), new THREE.MeshStandardMaterial({color:0xeeeeee}));
        cargo.position.set(0, 1.6, -0.6); cargo.castShadow=true;
        truck.add(cargo);

        // Ruote
        const wheelGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.3, 12);
        const wheelMat = new THREE.MeshStandardMaterial({color:0x111});
        [ [0.6, 1.2], [-0.6, 1.2], [0.6, -0.5], [-0.6, -0.5], [0.6, -1.5], [-0.6, -1.5] ].forEach(pos => {
            const wh = new THREE.Mesh(wheelGeo, wheelMat);
            wh.rotation.z = Math.PI/2;
            wh.position.set(pos[0], 0.35, pos[1]);
            truck.add(wh);
        });

        // Luci
        const light = new THREE.SpotLight(0xffffee, 2, 30, 0.5, 0.5);
        light.position.set(0, 3, 1);
        light.target.position.set(0,0,10);
        truck.add(light); truck.add(light.target);

        return truck;
    }

    // 2. AUTO (Traffic)
    function createCar(color) {
        const grp = new THREE.Group();
        const mat = new THREE.MeshStandardMaterial({color: color});
        
        const body = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.6, 3), mat);
        body.position.y = 0.6; body.castShadow=true;
        grp.add(body);

        const top = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.5, 1.6), mat);
        top.position.y = 1.15; top.castShadow=true;
        grp.add(top);

        const win = new THREE.Mesh(new THREE.BoxGeometry(1.12, 0.4, 1.4), new THREE.MeshStandardMaterial({color:0x222}));
        win.position.y = 1.16;
        grp.add(win);

        return grp;
    }

    // --- WORLD GENERATION ---
    const grid = []; // 0=Strada, 1=Edificio
    const colliders = []; // Array di Box3 per gli edifici
    const roadTiles = []; // Lista di coordinate valide per spawn traffico e goal

    const cityGroup = new THREE.Group();
    scene.add(cityGroup);

    // Pavimento
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(300, 300), new THREE.MeshStandardMaterial({color:0x333333}));
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = true;
    scene.add(floor);

    // Grid Setup
    for(let x=0; x<MAP_SIZE; x++){
        grid[x] = [];
        for(let z=0; z<MAP_SIZE; z++){
            // Bordi = Muri
            if(x===0 || z===0 || x===MAP_SIZE-1 || z===MAP_SIZE-1) {
                grid[x][z] = 1;
            } else {
                // Griglia Manhattan: x dispari e z dispari sono palazzi
                if(x%2 !== 0 && z%2 !== 0) grid[x][z] = 1;
                else grid[x][z] = 0;
            }
        }
    }

    // Costruzione
    for(let x=0; x<MAP_SIZE; x++){
        for(let z=0; z<MAP_SIZE; z++){
            const px = x * TILE_SIZE - OFFSET;
            const pz = z * TILE_SIZE - OFFSET;

            if(grid[x][z] === 1) {
                // EDIFICIO
                const h = Math.random() * 6 + 4;
                // Geometria leggermente pi√π piccola del tile per evitare compenetrazioni grafiche
                const geo = new THREE.BoxGeometry(TILE_SIZE-0.2, h, TILE_SIZE-0.2);
                
                // Fix UV per texture
                geo.attributes.uv.array.forEach((v,i) => { if(i%2===1 && v>0) geo.attributes.uv.array[i] = h/4; });
                
                const build = new THREE.Mesh(geo, materialsBuilding);
                build.position.set(px, h/2, pz);
                build.castShadow = true; build.receiveShadow = true;
                cityGroup.add(build);

                // Cornicione
                const rim = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 0.3, TILE_SIZE), new THREE.MeshStandardMaterial({color:0x111}));
                rim.position.set(px, h, pz);
                cityGroup.add(rim);

                // COLLISION BOX (Importante: leggermente pi√π stretto del visibile per perdonare gli urti)
                const box = new THREE.Box3().setFromObject(build);
                // Restringiamo di 0.1 per lato per evitare falsi positivi
                box.min.x += 0.1; box.max.x -= 0.1;
                box.min.z += 0.1; box.max.z -= 0.1;
                colliders.push(box);

                // Base marciapiede (solo decorativa)
                const sw = new THREE.Mesh(new THREE.BoxGeometry(TILE_SIZE, 0.2, TILE_SIZE), new THREE.MeshStandardMaterial({color:0x555}));
                sw.position.set(px, 0.1, pz);
                cityGroup.add(sw);

            } else {
                // STRADA
                roadTiles.push({x: x, z: z, px: px, pz: pz});
                
                // Linea mezzeria
                const line = new THREE.Mesh(new THREE.PlaneGeometry(0.3, TILE_SIZE), new THREE.MeshBasicMaterial({color:0x888}));
                line.rotation.x = -Math.PI/2;
                
                // Logica orientamento linea
                // Se i vicini X sono edifici, la strada va in Z (linea verticale)
                const leftIsBuild = (x>0 && grid[x-1][z] === 1);
                if(leftIsBuild) {
                     line.position.set(px, 0.02, pz);
                } else {
                     line.rotation.z = Math.PI/2;
                     line.position.set(px, 0.02, pz);
                }
                cityGroup.add(line);
            }
        }
    }

    // --- PLAYER ---
    const player = createTruck();
    scene.add(player);
    // Collision Box Player (Dimensioni fisse per stabilit√†)
    const playerSize = { w: 1.4, d: 3.8 }; 

    // Physics Params
    let speed = 0;
    const MAX_SPEED = 0.45; // Lento ma giusto
    const ACCEL = 0.01;
    const TURN_SPEED = 0.05;
    const FRICTION = 0.92; // Fermata rapida

    // --- TRAFFIC SYSTEM ---
    const traffic = [];
    const carColors = [0xd32f2f, 0x1976d2, 0x388e3c, 0xfbc02d, 0x7b1fa2, 0x455a64];
    
    // Spawn Logic Rigida
    function spawnCar() {
        if(traffic.length > 8) return;

        // Scegliamo se spawnare su asse X o Z (Strade sono indici pari)
        // Strade orizzontali (X Axis roads) sono alle righe z pari: 2, 4, 6...
        // Strade verticali (Z Axis roads) sono alle colonne x pari: 2, 4, 6...
        
        const isX = Math.random() > 0.5;
        const laneIndex = (Math.floor(Math.random() * (MAP_SIZE/2 - 1)) + 1) * 2; // 2, 4, 6...
        
        if(laneIndex >= MAP_SIZE-1) return;

        const laneCenter = laneIndex * TILE_SIZE - OFFSET;
        const spawnDist = (MAP_SIZE * TILE_SIZE)/2 + 10; // Fuori mappa
        
        // OFFSET PER CORSIA DESTRA
        // Strada larga TILE_SIZE (8). Centro √® 0.
        // Auto larga 1.4. Corsia dx √® offset positivo o negativo in base a direzione.
        const laneOffset = TILE_SIZE / 4; 

        const car = createCar(carColors[Math.floor(Math.random()*carColors.length)]);
        let dir, startPos;

        if(isX) {
            // Strada corre lungo X. Spawniamo a DX o SX?
            const goRight = Math.random() > 0.5;
            // Se va a destra (dir +1), deve stare nella parte "gi√π" della strada (Z positivo rispetto al centro tile)
            // Se va a sinistra (dir -1), deve stare nella parte "su" (Z negativo)
            // Coordinate: X varia, Z fissa.
            const zPos = laneCenter + (goRight ? laneOffset : -laneOffset);
            
            car.position.set(goRight ? -spawnDist : spawnDist, 0, zPos);
            car.rotation.y = goRight ? Math.PI/2 : -Math.PI/2;
            dir = new THREE.Vector3(goRight?1:-1, 0, 0);
        } else {
            // Strada corre lungo Z.
            const goDown = Math.random() > 0.5;
            // Se va gi√π (dir +1), deve stare a destra (X negativo rispetto al centro tile)
            // ASPETTA: Coordinate 3D. X destra, Z gi√π.
            // Se vado gi√π (+Z), la mia destra √® -X.
            // Se vado su (-Z), la mia destra √® +X.
            const xPos = laneCenter + (goDown ? -laneOffset : laneOffset);
            
            car.position.set(xPos, 0, goDown ? -spawnDist : spawnDist);
            car.rotation.y = goDown ? 0 : Math.PI;
            dir = new THREE.Vector3(0, 0, goDown?1:-1);
        }

        car.userData = { dir: dir, speed: 0.15 + Math.random()*0.1 };
        scene.add(car);
        traffic.push(car);
    }
    setInterval(spawnCar, 1500);

    // --- GOAL ---
    const goal = new THREE.Group();
    const gBox = new THREE.Mesh(new THREE.BoxGeometry(1.5,1.5,1.5), new THREE.MeshStandardMaterial({color:0x00ff00, emissive:0x005500}));
    gBox.position.y=1;
    const gArr = new THREE.Mesh(new THREE.ConeGeometry(0.5,1,8), new THREE.MeshBasicMaterial({color:0xffff00}));
    gArr.position.y=2.5; gArr.rotation.z=Math.PI;
    goal.add(gBox); goal.add(gArr);
    scene.add(goal);

    function moveGoal() {
        // Prendi un tile strada a caso
        const r = roadTiles[Math.floor(Math.random()*roadTiles.length)];
        goal.position.set(r.px, 0, r.pz);
    }
    moveGoal();

    // --- INPUT ---
    const joy = { x:0, y:0, on:false, ox:0, oy:0 };
    const jZone = document.getElementById('joystick-zone');
    const jBase = document.getElementById('stick-base');
    const jHand = document.getElementById('stick-handle');

    jZone.addEventListener('touchstart', e=>{
        e.preventDefault();
        const t=e.touches[0]; joy.on=true; joy.ox=t.clientX; joy.oy=t.clientY;
        jBase.style.display='block'; jBase.style.left=t.clientX+'px'; jBase.style.top=t.clientY+'px';
        jHand.style.transform=`translate(-50%,-50%)`;
    });
    jZone.addEventListener('touchmove', e=>{
        if(!joy.on)return; e.preventDefault();
        const t=e.touches[0];
        const dx=t.clientX-joy.ox; const dy=t.clientY-joy.oy;
        const d=Math.min(Math.sqrt(dx*dx+dy*dy), 50);
        const a=Math.atan2(dy,dx);
        joy.x = Math.cos(a)*d/50; joy.y = Math.sin(a)*d/50;
        jHand.style.transform=`translate(calc(-50% + ${Math.cos(a)*d}px), calc(-50% + ${Math.sin(a)*d}px))`;
    });
    const stopJoy = ()=>{ joy.on=false; joy.x=0; joy.y=0; jBase.style.display='none'; };
    jZone.addEventListener('touchend', stopJoy);
    jZone.addEventListener('touchcancel', stopJoy);

    // --- LOGIC ---
    let score = 0;
    let gameOver = false;
    const scoreEl = document.getElementById('score');
    const goScreen = document.getElementById('game-over-screen');

    function resetGame() {
        // Respawn su una tile sicura
        const startTile = roadTiles[Math.floor(Math.random()*roadTiles.length)];
        player.position.set(startTile.px, 0, startTile.pz);
        player.rotation.set(0,0,0);
        speed=0;
        score=0; scoreEl.innerText='0';
        gameOver=false; goScreen.style.display='none';
        
        traffic.forEach(t=>scene.remove(t));
        traffic.length=0;
        moveGoal();
    }

    // Helper Collisione Box Player vs Array Box
    function checkCollisions(newPos) {
        // Crea box virtuale alla nuova posizione
        const pBox = new THREE.Box3();
        const halfW = playerSize.w/2; 
        const halfD = playerSize.d/2;
        
        // Approssimazione box AABB (non ruotato perfettamente per semplicit√† calcolo sliding, ma efficace)
        // Per essere pi√π precisi, prendiamo il minimo e massimo ruotato o usiamo un raggio fisso.
        // Usiamo un raggio fisso per collisione "circolare" con i muri √® meglio per scivolare
        const radius = 0.7; // Met√† larghezza camion
        
        // Check contro Box3 muri
        for(let wall of colliders) {
            // Semplice check AABB vs Point + Radius
            // Clamping del punto player dentro il box muro per trovare il punto pi√π vicino
            const cx = Math.max(wall.min.x, Math.min(newPos.x, wall.max.x));
            const cz = Math.max(wall.min.z, Math.min(newPos.z, wall.max.z));
            
            const dx = newPos.x - cx;
            const dz = newPos.z - cz;
            const dist = Math.sqrt(dx*dx + dz*dz);
            
            if(dist < radius) {
                return true;
            }
        }
        return false;
    }

    function update() {
        if(gameOver) return;

        // INPUT & FISICA
        if(Math.abs(joy.x)>0.1 || Math.abs(joy.y)>0.1) {
            speed += ACCEL;
            const targetRot = Math.atan2(joy.x, joy.y);
            let delta = targetRot - player.rotation.y;
            while(delta > Math.PI) delta -= Math.PI*2;
            while(delta < -Math.PI) delta += Math.PI*2;
            // Sterzata rallenta se vai piano
            player.rotation.y += delta * TURN_SPEED * (Math.min(speed, 0.2)/0.2); 
        } else {
            speed *= FRICTION;
        }
        speed = Math.min(speed, MAX_SPEED);

        // MOVIMENTO CON SLIDING (Collisione separata assi)
        const dx = Math.sin(player.rotation.y) * speed;
        const dz = Math.cos(player.rotation.y) * speed;

        // 1. Prova X
        const nextPosX = player.position.clone();
        nextPosX.x += dx;
        if(!checkCollisions(nextPosX)) {
            player.position.x += dx;
        } else {
            // Se colpisce muro, frena un po'
            speed *= 0.9; 
        }

        // 2. Prova Z (Indipendentemente da X)
        const nextPosZ = player.position.clone();
        nextPosZ.z += dz;
        if(!checkCollisions(nextPosZ)) {
            player.position.z += dz;
        } else {
            speed *= 0.9;
        }

        // CAMERA
        camera.position.x += (player.position.x - camera.position.x)*0.1;
        camera.position.z += (player.position.z + 25 - camera.position.z)*0.1;
        camera.lookAt(player.position.x, 0, player.position.z);

        // TRAFFICO
        const pBox = new THREE.Box3().setFromObject(player);
        pBox.expandByScalar(-0.3); // Hitbox pi√π piccola per tolleranza
        const cBox = new THREE.Box3();

        for(let i=traffic.length-1; i>=0; i--){
            const t = traffic[i];
            t.position.addScaledVector(t.userData.dir, t.userData.speed);
            
            cBox.setFromObject(t); cBox.expandByScalar(-0.1);
            if(cBox.intersectsBox(pBox)) {
                gameOver = true; goScreen.style.display='flex';
            }

            // Despawn
            if(Math.abs(t.position.x)>200 || Math.abs(t.position.z)>200) {
                scene.remove(t); traffic.splice(i,1);
            }
        }

        // GOAL
        gBox.rotation.y+=0.05;
        gBox.rotation.x+=0.02;
        const gRect = new THREE.Box3().setFromObject(gBox);
        if(gRect.intersectsBox(pBox)) {
            score++; scoreEl.innerText=score; moveGoal();
        }
        
        drawMinimap();
    }

    // --- MINIMAP FIXED ---
    const mmCanvas = document.getElementById('minimap-canvas');
    const ctx = mmCanvas.getContext('2d');
    mmCanvas.width = 150; mmCanvas.height = 150;

    function drawMinimap() {
        // Sfondo
        ctx.fillStyle = '#111';
        ctx.fillRect(0,0,150,150);
        
        const cx = 75; const cy = 75;
        const scale = 4; // Zoom factor

        // Trasformazione Matrice: 
        // Vogliamo che il Player sia fermo al centro (cx, cy) e punti in alto.
        // Il mondo deve ruotare opposto al player e traslare opposto.
        
        ctx.save();
        
        ctx.translate(cx, cy);
        ctx.rotate(player.rotation.y); // Ruota il mondo (opposto alla rotazione camera visuale)
        ctx.translate(-player.position.x * scale, -player.position.z * scale); // Sposta il mondo

        // 1. Disegna Edifici
        ctx.fillStyle = '#666';
        for(let x=0; x<MAP_SIZE; x++){
            for(let z=0; z<MAP_SIZE; z++){
                if(grid[x][z]===1) {
                    const px = x*TILE_SIZE - OFFSET;
                    const pz = z*TILE_SIZE - OFFSET;
                    // Disegna rettangolo edificio
                    // Nota: Le coordinate canvas Y crescono in basso, nel 3D Z cresce in basso. Ok.
                    // X cresce a destra in entrambi. Ok.
                    // Ma nel 3D +X √® destra, nel canvas +X √® destra.
                    // Bisogna fare attenzione alla rotazione iniziale.
                    // ThreeJS: X right, Z down (top view).
                    // Canvas: X right, Y down.
                    // Sembra combaciare.
                    
                    // Cull per performance (disegna solo se vicino)
                    if(Math.abs(px - player.position.x) < 60 && Math.abs(pz - player.position.z) < 60)
                        ctx.fillRect(px*scale - (TILE_SIZE*scale)/2, pz*scale - (TILE_SIZE*scale)/2, TILE_SIZE*scale, TILE_SIZE*scale);
                }
            }
        }

        // 2. Goal
        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.arc(goal.position.x*scale, goal.position.z*scale, 6, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();

        // 3. Player (Sempre al centro, punta in alto, ma il mondo √® ruotato per far sembrare che lui ruoti?
        // NO. Nel mio codice sopra ho ruotato il mondo di +playerRot.
        // Se il player ruota a destra (+Rot), il mondo ruota a destra, quindi il player sembra andare a sinistra. Errore.
        // Correggiamo: rotazione mondo deve essere -playerRot? 
        // Proviamo a disegnare il player statico che punta in SU.
        
        ctx.fillStyle = '#f39c12';
        ctx.beginPath();
        ctx.moveTo(cx, cy - 8);
        ctx.lineTo(cx + 6, cy + 8);
        ctx.lineTo(cx - 6, cy + 8);
        ctx.fill();
    }

    // Correction on Minimap Rotation Logic inside loop
    // drawMinimap usa `ctx.rotate(player.rotation.y)`. 
    // Se player ruota di 90deg (PI/2), punta a destra nel 3D.
    // Se ruoto il canvas di 90deg, l'asse Y (che punta gi√π) va a sinistra. 
    // Se disegno il mondo, tutto ruota.
    // Vogliamo che se il player guarda a Est (+X), l'Est sia "in alto" nella minimappa.
    // Quindi dobbiamo ruotare il mondo di -PI/2.
    // Quindi la formula corretta √® `ctx.rotate(player.rotation.y)`. Aspetta.
    // Se player.rot = 0 (Guarda Sud/Gi√π +Z).
    // Minimap Arrow punta SU. Mondo deve essere capovolto?
    // Facciamo semplice: Player statico. Mondo ruotato di `player.rotation.y`.

    function animate() {
        requestAnimationFrame(animate);
        update();
        renderer.render(scene, camera);
    }
    resetGame();
    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>